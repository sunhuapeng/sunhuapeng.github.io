import {
  CopyShader
} from "./chunk.UATTKJOJ.js";
import {
  FullScreenQuad
} from "./chunk.5J2KQ3NY.js";
import {
  Pass
} from "./chunk.BXIYVJKC.js";
import {
  AdditiveBlending,
  LinearFilter,
  RGBAFormat,
  ShaderMaterial,
  UniformsUtils,
  Vector2,
  WebGLRenderTarget
} from "./chunk.7RLSBAIC.js";

// node_modules/three/examples/jsm/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    KERNEL_SIZE_FLOAT: "25.0",
    KERNEL_SIZE_INT: "25"
  },
  uniforms: {
    tDiffuse: {value: null},
    uImageIncrement: {value: new Vector2(1953125e-9, 0)},
    cKernel: {value: []}
  },
  vertexShader: `

		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float cKernel[ KERNEL_SIZE_INT ];

		uniform sampler2D tDiffuse;
		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vec2 imageCoord = vUv;
			vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );

			for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {

				sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];
				imageCoord += uImageIncrement;

			}

			gl_FragColor = sum;

		}`,
  buildKernel: function(sigma) {
    const kMaxKernelSize = 25;
    let kernelSize = 2 * Math.ceil(sigma * 3) + 1;
    if (kernelSize > kMaxKernelSize)
      kernelSize = kMaxKernelSize;
    const halfWidth = (kernelSize - 1) * 0.5;
    const values = new Array(kernelSize);
    let sum = 0;
    for (let i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    }
    for (let i = 0; i < kernelSize; ++i)
      values[i] /= sum;
    return values;
  }
};
function gauss(x, sigma) {
  return Math.exp(-(x * x) / (2 * sigma * sigma));
}

// node_modules/three/examples/jsm/postprocessing/BloomPass.js
var BloomPass = class extends Pass {
  constructor(strength = 1, kernelSize = 25, sigma = 4, resolution = 256) {
    super();
    const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
    this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);
    this.renderTargetX.texture.name = "BloomPass.x";
    this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);
    this.renderTargetY.texture.name = "BloomPass.y";
    if (CopyShader === void 0)
      console.error("THREE.BloomPass relies on CopyShader");
    const copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = strength;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true
    });
    if (ConvolutionShader === void 0)
      console.error("THREE.BloomPass relies on ConvolutionShader");
    const convolutionShader = ConvolutionShader;
    this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
    this.convolutionUniforms["cKernel"].value = ConvolutionShader.buildKernel(sigma);
    this.materialConvolution = new ShaderMaterial({
      uniforms: this.convolutionUniforms,
      vertexShader: convolutionShader.vertexShader,
      fragmentShader: convolutionShader.fragmentShader,
      defines: {
        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),
        KERNEL_SIZE_INT: kernelSize.toFixed(0)
      }
    });
    this.needsSwap = false;
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
  }
};
BloomPass.blurX = new Vector2(1953125e-9, 0);
BloomPass.blurY = new Vector2(0, 1953125e-9);
export {
  BloomPass
};
//# sourceMappingURL=three_examples_jsm_postprocessing_BloomPass.js.map
