{
  "version": 3,
  "sources": ["../three/examples/jsm/loaders/DDSLoader.js"],
  "sourcesContent": ["import {\n\tCompressedTextureLoader,\n\tRGBAFormat,\n\tRGBA_S3TC_DXT3_Format,\n\tRGBA_S3TC_DXT5_Format,\n\tRGB_ETC1_Format,\n\tRGB_S3TC_DXT1_Format\n} from 'three';\n\nclass DDSLoader extends CompressedTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tconst DDS_MAGIC = 0x20534444;\n\n\t\t// let DDSD_CAPS = 0x1;\n\t\t// let DDSD_HEIGHT = 0x2;\n\t\t// let DDSD_WIDTH = 0x4;\n\t\t// let DDSD_PITCH = 0x8;\n\t\t// let DDSD_PIXELFORMAT = 0x1000;\n\t\tconst DDSD_MIPMAPCOUNT = 0x20000;\n\t\t// let DDSD_LINEARSIZE = 0x80000;\n\t\t// let DDSD_DEPTH = 0x800000;\n\n\t\t// let DDSCAPS_COMPLEX = 0x8;\n\t\t// let DDSCAPS_MIPMAP = 0x400000;\n\t\t// let DDSCAPS_TEXTURE = 0x1000;\n\n\t\tconst DDSCAPS2_CUBEMAP = 0x200;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n\t\t// let DDSCAPS2_VOLUME = 0x200000;\n\n\t\t// let DDPF_ALPHAPIXELS = 0x1;\n\t\t// let DDPF_ALPHA = 0x2;\n\t\tconst DDPF_FOURCC = 0x4;\n\t\t// let DDPF_RGB = 0x40;\n\t\t// let DDPF_YUV = 0x200;\n\t\t// let DDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t);\n\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 4;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( dataLength );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst a = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tconst FOURCC_DXT1 = fourCCToInt32( 'DXT1' );\n\t\tconst FOURCC_DXT3 = fourCCToInt32( 'DXT3' );\n\t\tconst FOURCC_DXT5 = fourCCToInt32( 'DXT5' );\n\t\tconst FOURCC_ETC1 = fourCCToInt32( 'ETC1' );\n\n\t\tconst headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tconst off_magic = 0;\n\n\t\tconst off_size = 1;\n\t\tconst off_flags = 2;\n\t\tconst off_height = 3;\n\t\tconst off_width = 4;\n\n\t\tconst off_mipmapCount = 7;\n\n\t\tconst off_pfFlags = 20;\n\t\tconst off_pfFourCC = 21;\n\t\tconst off_RGBBitCount = 22;\n\t\tconst off_RBitMask = 23;\n\t\tconst off_GBitMask = 24;\n\t\tconst off_BBitMask = 25;\n\t\tconst off_ABitMask = 26;\n\n\t\t// let off_caps = 27;\n\t\tconst off_caps2 = 28;\n\t\t// let off_caps3 = 29;\n\t\t// let off_caps4 = 30;\n\n\t\t// Parse header\n\n\t\tconst header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tlet blockBytes;\n\n\t\tconst fourCC = header[ off_pfFourCC ];\n\n\t\tlet isRGBAUncompressed = false;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_ETC1_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\n\t\t\t\t}\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\tconst caps2 = header[ off_caps2 ];\n\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\tif ( dds.isCubemap && (\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t) ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\tlet dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tconst faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\tlet width = dds.width;\n\t\t\tlet height = dds.height;\n\n\t\t\tfor ( let i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tlet byteArray, dataLength;\n\n\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = byteArray.length;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tbyteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t}\n\n\t\t\t\tconst mipmap = { 'data': byteArray, 'width': width, 'height': height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dds;\n\n\t}\n\n}\n\nexport { DDSLoader };\n"],
  "mappings": "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",
  "names": []
}
