// 用来计算模型单模块的各种数据
let THREE
export class Box {
  protected THREE: any = null
  constructor(t) {
    THREE = t
  }
  // 获取包围盒
  getBox(mesh) {
    if (mesh instanceof THREE.Object3D) {
      let b = new THREE.Box3();
      b.expandByObject(mesh);
      return b
    } else {
      console.error('请传入正确的模型')
    }
  }
  // 获取中心点
  getCenter(mesh, v3): void {
    if (v3 instanceof THREE.Vector3) {
      this.getBox(mesh).getCenter(v3);
    } else {
      console.error('参数错误')
    }
  }
  getRayLatelyVetex(mesh, point, direction?: string) {
    const center = new THREE.Vector3()
    this.getCenter(mesh, center)
    const size = new THREE.Vector3()
    this.getSize(mesh, size)
    const star = center.clone()
    const end = center.clone()
    if (!direction || direction === 'y') {
      end.y = end.y - size.y
      star.y = star.y + size.y
    } else {
      end[direction] = end[direction] - size[direction]
      star[direction] = star[direction] + size[direction]
    }
    const v3 = new THREE.Vector3()
    var raycaster = new THREE.Raycaster(star, end); // 正向射线
    var intersects = raycaster.intersectObject(mesh, true);
    console.log('intersects', intersects)
    if (intersects.length !== 0) {
      point.copy(center)
    } else {
      let minLength: number = 0
      // let vector3: any = new THREE.Vector3()
      const pArr = mesh.geometry.attributes.position.array
      const pI = mesh.geometry.attributes.position.count

      for (let i = 0; i < pI; i++) {
        const limit = i * 3
        v3.fromArray(pArr, limit)
        let p3 = center.clone().sub(v3); //两点之间的中心点
        let l = p3.length(); // 两点之间的距离
        if (i == 0) {
          minLength = l
          point.copy(v3)
        } else {
          if (minLength > l) {
            minLength = l
            point.copy(v3)
          }
        }
      }
    }
  }
  getSize(mesh, v3): void {
    if (v3 instanceof THREE.Vector3) {
      this.getBox(mesh).getSize(v3);
    } else {
      console.error('参数错误')
    }
  }
  // 获取面积 x*y | x*z | y*z
  getArea(mesh, first?: string | undefined, second?: string | undefined): number {
    const size = new THREE.Vector3()
    this.getSize(mesh, size)
    const area = Math.floor(size[first || 'x'] * size[second || 'z'])
    return area
  }
}

export class GltfLoader {
  loader
  constructor(GLTFLoader, DRACOLoader) {
    this.loader = new GLTFLoader();
    this.loader.setDRACOLoader(new DRACOLoader());
  }
  create(url: string) {
    return new Promise(
      (resolve) => {
        this.loader.load(url, (gltf: any) => {
          const model = gltf.scene
          console.log(gltf)
          resolve(model)
        });
      }
    )
  }
}
