import{o as e,c as n,a as t}from"./index.f1c5fd80.js";const p={class:"markdown-body"},a=t('<html><p class="title" style="display:none;">一些three.js的基础——加载FBX模型 </p></html><html><p class="article_id" style="display:none;">6911217131254185991</p></html><html><p class="target" style="display:none;">前端</p></html><html><p class="create_time" style="display:none;">1618841071708</p></html><html><p class="update_time" style="display:none;">1609143155003</p></html><html><p class="cover_image" style="display:none;">https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4838afdfc1045bc88798ea761120e7f~tplv-k3u1fbpfcp-watermark.image</p></html><html><p class="brief_content" style="display:none;">... 3D工程师在交给你一项3D工程的时候会有很多贴图，比如发光贴图，凹凸贴图、颜色贴图、环境贴图、等等...</p></html><p>1、创建一个基础场景 包含场景<code>scene</code>、透视相机<code>PerspectiveCamera</code>、控制器<code>OrbitControls</code>、点光源<code>PointLight</code>、半球光<code>HemisphereLight</code>、渲染器<code>WebGLRenderer</code>，以及今天的主角<code>FBXLoader</code> fbx加载器 场景背景颜色设置为<code>0xf65144</code></p><pre><code class="language-javascript">\nscene = new THREE.Scene();scene = new THREE.Scene();scene = new THREE.Scene();scene = new THREE.Scene();scene = new THREE.Scene();scene = new THREE.Scene();scene = new THREE.Scene();\n\nscene.fog = new THREE.Fog(0x000000, 600, 3000); //雾化场景\n\nscene.background = new THREE.Color(0xf65144);\n\n</code></pre><p>透视相机位置设置为正对x轴</p><pre><code class="language-javascript">\ncamera = new THREE.PerspectiveCamera(\n    \n      45,\n\n  window.innerWidth / window.innerHeight,\n\n  1,\n\n  10000\n\n);\n\ncamera.position.set(0, 0, 200); //设置相机位置\n\n</code></pre><p>灯光采用半球光和点光源两种</p><p>半球光用来渲染整个场景的颜色，点光源用来渲染模型高光</p><pre><code class="language-javascript">\n// 设置光照\n\n// 半球光\n\nconst hemisphereLight = new THREE.HemisphereLight(\n    \n    0xffffff,\n\n0x444444,\n\n1\n\n);\n\n// hemisphereLight.position.set(0, 200, 0);\n\nscene.add(hemisphereLight);\n\n// 点光源\n\nlight = new THREE.PointLight(0xffff00, 2, 100);\n\nlight.position.set(0, 0, 0);\n\nscene.add(light);\n\n\n\n</code></pre><p>…</p><p>所有基础元素创建完成后，可以在页面看到这样的场景</p><p>&lt;img src=“<a href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df963a4eda744ae7b8cf04ee1dac9009~tplv-k3u1fbpfcp-watermark.image">https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df963a4eda744ae7b8cf04ee1dac9009~tplv-k3u1fbpfcp-watermark.image</a>” style=“zoom:33%;” /&gt;</p><p>接下载要使用到fbxloader</p><p>文件的引用</p><pre><code>\n    &lt;script src=\\&quot;../../../three.js-master\\\\examples\\\\js\\\\loaders\\\\FBXLoader.js\\&quot;&gt;&lt;/script&gt;\n\n</code></pre><p>因为是在html内写的代码，所以路径为当前文件的相对路径，可以根据自己文件位置进行更改</p><p>官网内有对于fbx加载器的使用，这里不赘述，主要讲一下材质和贴图</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45f72ed4e0f4b5b8eb06b9748b7a7ad~tplv-k3u1fbpfcp-watermark.image" alt=""></p><pre><code class="language-javascript">\n// 模型地址\n\nconst url = \\&quot;../model/fbx/beats耳机/source/beats_highpoly.fbx\\&quot;\n\nconst loader = new THREE.FBXLoader()\n\nloader.load(\n    \n    url,\n\nfunction (loadedModel) {\n    \n    console.log(loadedModel);\n\nmesh = loadedModel.children[0].clone();\n\nscene.add(mesh);\n\n}\n\n);\n\n</code></pre><p>在加载的过程中遇到一些小问题，fbx依赖的Inflate.min.js文件找不到</p><p>需要在js中引入intflate.min.js</p><pre><code class="language-javascript">\n&lt;script src=\\&quot;../../../three.js-master\\\\examples\\\\js\\\\loaders\\\\FBXLoader.js\\&quot;&gt;&lt;/script&gt;\n\n&lt;script src=\\&quot;../../../three.js-master\\\\examples\\\\js\\\\libs\\\\inflate.min.js\\&quot;&gt;&lt;/script&gt;\n\n</code></pre><p>加载后可以看出来，没有对模型进行材质的修改和贴图，材质本身是黑色的</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4ba70b5885a41d6ab1d27bd7f8e72d6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>在上面代码中，我们打印一下<code>loadedModel</code> 是一个组对象<code>group</code>，组对象没有材质，而且并不是咱们最终要加载的模型对象，可以看一下组对象的children中的结果，有一个mesh对象，这是咱们需要渲染的对象，打印一下可以看到material材质对象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df793546c41e44e6a8653fd944980b91~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>模型本身的材质是一个<a href="https://threejs.org/docs/index.html#api/zh/materials/MeshPhongMaterial">Phong网格材质</a></p><p>那么一会的贴图也会选择这样的材质</p><p>首选如果要贴图肯定需要将贴图加载为纹理，这样就要用到 <code>TextureLoader</code></p><pre><code class="language-javascript">\nconst textureLoader = new THREE.TextureLoader();\n\nconst textureUrl = \\&quot;../model/fbx/beats耳机/textures/beats_red.png\\&quot;\n\nconst textureNormal = textureLoader.load(\n    \n      textureUrl\n\n);\n\n</code></pre><p>原本贴图样式</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc0fe131a1b24078a654f7ebe90a7d63~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这张图，是3D工程师导出工程的时候通过某种手段生成的，感兴趣的童鞋可以跟身边的3D工程师了解</p><p>至于每个贴图点，每个位置能够对应上模型，也是在3D工程生成时候计算好的，作为前端只是拿来用就可以</p><p>接下来对模型进行材质的重新渲染</p><pre><code>\nmesh = loadedModel.children[0].clone();\n\nmesh.material = new THREE.MeshPhongMaterial({\n    \n      color: 0x00ffff,\n\n})\n\nconsole.log(mesh);\n\nscene.add(mesh);\n\n</code></pre><p>先小试一下</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aa16870544347949c5d224908513004~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>通过已经被改变的颜色不难发现，可以对模型的材质进行修改</p><p>接下来需要将我们加载好的纹理贴图和模型结合上，</p><p>3D工程师在交给你一项3D工程的时候会有很多贴图，比如发光贴图，凹凸贴图、颜色贴图、环境贴图、等等…</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c973183b56c34751a723751cc5554437~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>可以通过这里看出来之前默认为null的表示之前并未对它进行材质贴图，也可以通过官网上面的material查看这些贴图具体什么作用</p><p>此次我们要对贴图进行重新渲染的是map 颜色贴图</p><p>所以将map设置为之前定义的 <code>textureNormal</code> 即可</p><pre><code class="language-javascript">\n// 模型地址\n\nconst url = \\&quot;../model/fbx/beats耳机/source/beats_highpoly.fbx\\&quot;;\n\nconst loader = new THREE.FBXLoader();\n\nloader.load(url, function (loadedModel) {\n    \n    const textureLoader = new THREE.TextureLoader();\n\nconst textureUrl =  \\&quot;../model/fbx/beats耳机/textures/beats_red.png\\&quot;\n\nconst textureNormal = textureLoader.load(\n    \n    textureUrl\n\n);\n\nmesh = loadedModel.children[0].clone();\n\nmesh.material.map = textureNormal\n\nconsole.log(loadedModel.children[0]);\n\nscene.add(mesh)\n\n});\n\n</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78c6c1b019bf40049ed3931bd3390710~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>接下来我们就可以通过一些微调改变一下模型材质的展示</p><p>mesh.material中有一个属性<code>shininess</code> 控制高光显示程度，可以对它进行控制，修改高光具体显示程度</p><p>首先要调整的是灯光，我们之前对灯光只是设置上了，并没有调整打光的位置</p><pre><code>\n// 设置光照\n\n// 半球光\n\nconst hemisphereLight = new THREE.HemisphereLight(\n    \n      0xffaea8, // 天空发出颜色\n\n  0x7f0900, // 地面发出颜色\n\n  1 // 光照强度\n\n);\n\nhemisphereLight.position.set(0, 50, 60);\n\nscene.add(hemisphereLight);\n\n\n\n// 聚光灯\n\nconst spotLight = new THREE.SpotLight(0xffffff);\n\nspotLight.position.set(100, 60, 100);\n\nscene.add(spotLight);\n\n\n\nconst spotLightHelper = new THREE.SpotLightHelper(spotLight);\n\nscene.add(spotLightHelper);\n\n</code></pre><p>在渲染动画中，将点光源进行一个位置的转换，这样就可以调整出不同位置的高光</p><pre><code>\nfunction animate() {\n    \n    requestAnimationFrame(animate);\n\nconst time = Date.now() * 0.0005;\n\nif (light) {\n    \n      light.position.x = Math.sin(time * 0.7) * 50;\n\n  // light.position.y = Math.cos(time * 0.3) * 50;\n\n  light.position.z = Math.sin(time * 0.5) * 50;\n\n}\n\nrenderer.render(scene, camera);\n\n}\n\n</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d4fa8d4a16e46a39500dd7a0fa49d69~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>最终调整的效果如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12ab6b28f9f2457ebced483c0c0688a5~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>代码地址</p><p><a href="https://github.com/sunhuapeng/sunhuapeng_2.0/blob/master/public/html/%E4%B8%AD%E7%BA%A7%E6%A1%88%E4%BE%8Bhtml/loadTexture.html">html</a></p><p><a href="https://github.com/sunhuapeng/sunhuapeng_2.0/blob/master/public/html/model/fbx/beats%E8%80%B3%E6%9C%BA/source/beats_highpoly.fbx">模型</a></p><p><a href="https://github.com/sunhuapeng/sunhuapeng_2.0/blob/master/public/html/model/fbx/beats%E8%80%B3%E6%9C%BA/textures/beats_red.png">贴图</a></p>',65),s={expose:[],setup:t=>(defineExpose({frontmatter:{}}),(t,s)=>(e(),n("div",p,[a])))};export default s;
