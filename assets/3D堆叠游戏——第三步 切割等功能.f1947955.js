import{o as e,c as t,a as p}from"./index.391a9efd.js";const s={class:"markdown-body"},n=p('<html><p class="title" style="display:none;">3D堆叠游戏——第三步 切割等功能 </p></html><html><p class="article_id" style="display:none;">6912306652632842247</p></html><html><p class="target" style="display:none;">typescript|threejs</p></html><html><p class="create_time" style="display:none;">1609396814000</p></html><html><p class="update_time" style="display:none;">1609396814001</p></html><html><p class="cover_image" style="display:none;">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5aab718e22b4060ac0ad9612e5e8f03~tplv-k3u1fbpfcp-watermark.image</p></html><html><p class="brief_content" style="display:none;">在进行下一次主角出现之前需要做很多工作。第一步先对主角进行切割</p></html><p>接<a href="https://juejin.cn/post/6911947391369216013">上一篇</a>文章</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5aab718e22b4060ac0ad9612e5e8f03~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3>上一篇游戏功能做到主角的动画以及控制</h3><p>在进行下一次主角出现之前需要做很多工作。第一步先对主角进行切割</p><p>分出在有效范围内和有效范围外的模型</p><p>将有效范围内放置到场景内，有效范围外的模型做自由落体</p><p>切割主要用<code>threebsp</code></p><pre><code>require(\\&quot;../utils/threebsp.js\\&quot;);\n</code></pre><p>源码中将<code>threebsp</code>绑定到<code>windows</code>上，所以可以直接用<code>const ThreeBSP = (window as any).ThreeBSP</code>引用</p><pre><code>function ThreeBSP(treeIsh, matrix) {\n      this.matrix = matrix;\n    this.intersect = __bind(this.intersect, this);\n    this.union = __bind(this.union, this);\n    this.subtract = __bind(this.subtract, this);\n    this.toGeometry = __bind(this.toGeometry, this);\n    this.toMesh = __bind(this.toMesh, this);\n    this.toTree = __bind(this.toTree, this);\n    if (this.matrix == null) {\n        this.matrix = new THREE.Matrix4();\n    }\n    this.tree = this.toTree(treeIsh);\n  }\n</code></pre><p>这是源码中对几个方法的封装</p><p>intersect 处理结果为相交</p><p>union 处理结果为联合</p><p>subtract 处理结果为减法，前面的模型减去后面的模型得出的结果</p><p>感兴趣的童鞋可以阅读一下<a href="https://johnson2heng.github.io/three.js-demo/lib/threebsp.js">源码</a>，主要对顶点信息进行的计算</p><p>进行bsp计算之前需要将底板的高度提升和主角的高度一样，不然永远没有相交区域</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ced17c56ae46b58514935f131df85d~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>大概这个意思（灵魂画手表示哭泣）</p><h3>进行的相交计算</h3><p>计算的结果大致这样</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3732e01f4a242a4921f2e28ca28ed90~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>所以需要进行两次计算 一次相交计算 得到有效区域 一次减法计算 得到无效区域</p><p>先处理有效区域</p><pre><code>const ThreeBSP = (window as any).ThreeBSP\n//生成ThreeBSP对象\nvar leadBsp = new ThreeBSP(lead);\nvar lastLeadBsp = new ThreeBSP(lastLead);\n</code></pre><p>这样就得到两个bsp对象 <code>leadBsp</code> 和<code>lastLeadBsp</code></p><p>再进行裁切和模型材质赋值</p><pre><code class="language-typescript">function handleBsp(firstBSP: any, secondBSP: any, type: string) {\n    // 进行相减计算  前面的减去与后面进行交叉计算\n  var mesh\n  if(type === &#39;intersect&#39;) {\n      mesh = firstBSP.intersect(secondBSP);\n  }\n  if (type === &#39;subtract&#39;) {\n      mesh = firstBSP.subtract(secondBSP);\n  }\n\n  // 将裁剪的模块转为object\n  var intersectResult = mesh.toMesh();\n\n  //更新模型的面和顶点的数据\n  intersectResult.geometry.computeFaceNormals();\n  intersectResult.geometry.computeVertexNormals();\n\n  // 判断是否存在顶点信息\n  if (intersectResult.geometry.vertices.length &gt; 0) {\n      //重新赋值一个纹理\n    var material = new THREE.MeshNormalMaterial();\n    intersectResult.material = material;\n    return intersectResult\n  }\n}\n</code></pre><p>将计算好的结果 返回给initGame方法，再进行处理</p><pre><code>const intersectResult = handleBsp(leadBsp, lastLeadBsp, &#39;intersect&#39;)\nmeshList.push(intersectResult)\n\n</code></pre><h3>得到的结果</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36efa895c8054c6292e540f32869418f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>透明区域是抬高位置的底板</p><p>接下来处理多余的部分（无效区域）</p><p>方法是相同的 传不同的参数即可</p><p>然后通过有效区域，将下一次的主角定位有效区域的尺寸</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08a705a5f5a140ceb44c3c0ef700f4ce~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>接下来就是将此次的有效区域克隆<code>clone</code>一份，作为下一次的主角</p><pre><code class="language-typescript">this.leadCube = meshArr[0].clone()\n</code></pre><p>之前计算的位置关系再赋值给克隆的主角，</p><p>奇数在右侧出现的，修改z值位置，偶数在左侧出现的，修改x值</p><p>y值跟第一次创建主角时候使用同一种计算方式</p><pre><code>let nextPosition = this.leadCube.position.clone()\n// 奇数在右侧出现的，修改z值位置，偶数在左侧出现的，修改x值\nif (flag) {\n    nextPosition.setX(sx)\n} else {\n    nextPosition.setZ(sz)\n}\nnextPosition.setY(y)\nthis.leadCube.position.copy(nextPosition)\n</code></pre><h3>下面需要计算终点位置</h3><p>同样 如果是奇数 从右侧来，不改变z值 如果是偶数 从左侧来 不改变x值</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8fb316c521f46ddb9924e5bec7b0279~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>堆叠几次之后的效果</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7d5398a1fb14e43ab56ff5175f58614~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>那么接下来需要做一下无效区域的下落动画(非物理运动)</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81454944b41499e893207871c2f55ba~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>自由落体单独写吧，挺复杂的，游戏开发接近尾声，剩下记分器，镜头移动等其他功能</p><p><a href="https://juejin.cn/post/6911909496050843655">3D堆叠游戏——第一步 基础 初始化游戏</a></p><p><a href="https://juejin.cn/post/6911947391369216013">3D堆叠游戏——第二步 控制 控制主角移动以及停止</a></p>',59),i={expose:[],setup:p=>(defineExpose({frontmatter:{}}),(p,i)=>(e(),t("div",s,[n])))};export default i;
