import{o as e,c as n,a as o}from"./index.391a9efd.js";const r={class:"markdown-body"},l=o('<html><p class="title" style="display:none;">Typescript 的数据类型 </p></html><html><p class="article_id" style="display:none;">6844904143044214920</p></html><html><p class="target" style="display:none;">typescript</p></html><html><p class="create_time" style="display:none;">1589054435001</p></html><html><p class="update_time" style="display:none;">1519054435003</p></html><html><p class="cover_image" style="display:none;"> https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8c0a52167474efda5eeb47f8cdb1cbb~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image</p></html><html><p class="brief_content" style="display:none;">Typescript 的数据类型</p></html><h4>Typescript 的数据类型</h4><ol><li>布尔类型 boolean</li><li>数字类型 number</li><li>字符串类型 string</li><li>数组类型 array</li><li>元组类型 tuple （属于数组的一种）</li><li>枚举类型 enum</li><li>任意类型 any</li><li>null 和 undefined never的子类型</li><li>void 类型 表示没有类型</li><li>never 不存在值的类型</li></ol><h4>类型的应用</h4><h5>布尔类型</h5><pre><code class="language-typescript">// 未规定类型\nlet bool\nbool = false\nbool = 1  \nconsole.log(bool) // 1xxxxxxxxxx let bool = true// bool = &#39;&#39;  // 不能将类型“string”分配给类型“boolean”bool = false// 未规定类型let boolbool = falsebool = 1  console.log(bool) // 1typescript\n</code></pre><pre><code class="language-typescript">//  定义的时候默认赋值布尔值\nlet bool = true\nbool = 1 // 不能将类型“number”分配给类型“boolean”。\nconsole.log(bool) // 编译不通过\n</code></pre><p>这段代码片段相当于规定了 <code>bool:boolean</code></p><pre><code class="language-typescript"> let bool: boolean\n bool = false\n bool = true\n console.log(bool) //true\n</code></pre><h4></h4><h5>数字类型</h5><pre><code class="language-typescript"> let num:number\n\n num = 0\n\n console.log(num)  // 0\n</code></pre><h5>字符串类型</h5><pre><code class="language-typescript"> let str: string\n str = &#39;&#39;\n str = &#39;is a string&#39;\n\n console.log(str) // is a string\n</code></pre><h5>数组类型</h5><p>定义数组的时候需要规定数组内每一项的数据类型</p><p>未规定数组内每一项的数据类型</p><pre><code class="language-typescript">let arr: [] = []\n\narr.push(1)  // 类型“number”的参数不能赋给类型“never”的参数\n</code></pre><p>定义数组时规定数组内每一项数据类型</p><p>规定数组内每一项的数据类型</p><pre><code class="language-typescript">// 未规定数组内每一项的数据类型\nlet arr: string[] = []\n\narr.push(&#39;123&#39;)  // 类型“number”的参数不能赋给类型“never”的参数\n\n// 在规定数组内每一项的数据类型之后再push其他数据类型\narr.push(1) // 类型“number”的参数不能赋给类型“string”的参数。\n\n</code></pre><p>如果需要数组内有不同的数据类型可以使用元组类型</p><h5>元组类型</h5><pre><code class="language-typescript">let arr:[number, string] = [] \n//不能将类型“[]”分配给类型“[number, string]”。\n//源具有 0 个元素，但目标需要 2 个。\n\n// 元组类型规定数据类型的数据源数量需要跟定义的数量一样\nlet arr:[number, string] = [1,&#39;1&#39;]\n</code></pre><p>数组定义元祖类型后，只能添加规定的数据类型</p><pre><code class="language-typescript">// 元组类型规定数据类型的数据源数量需要跟定义的数量一样\nlet arr:[number, string] = [1,&#39;1&#39;]\narr.unshift(&#39;0&#39;)\narr.push(2)\narr.push(&#39;2&#39;)\nconsole.log(arr)  // [&quot;0&quot;, 1, &quot;1&quot;, 2, &quot;2&quot;]\n</code></pre><h5>枚举类型</h5><pre><code> \nenum Color { blue, red, yellow }\nconsole.log(Color)\n/**\n 打印结果\n    {\n        0: &quot;blue&quot;\n        1: &quot;red&quot;\n        2: &quot;yellow&quot;\n        blue: 0\n        red: 1\n        yellow: 2\n    }\n */\n</code></pre><p>对Color取值</p><pre><code class="language-typescript">\nenum Color { blue, red, yellow }\nconsole.log(Color)\n/**\n 打印结果\n    {\n        0: &quot;blue&quot;\n        1: &quot;red&quot;\n        2: &quot;yellow&quot;\n        blue: 0\n        red: 1\n        yellow: 2\n    }\n */\n\n let c:Color = Color.blue\n console.log(c) // 0\n</code></pre><p>修改下标</p><pre><code class="language-typescript">enum Color { blue, red = 3, yellow }\nlet c: Color = Color.yellow\nconsole.log(c) // 4 (修改后的下标)\n\n</code></pre><h5>任意类型</h5><p>任意类型any定义后可以对变量进行任意赋值</p><pre><code class="language-typescript"> let a:any = null\n a = 1\n console.log(a)  // 1\n</code></pre><h5>null和undefined</h5><p>对于需要明确表明不可用的情况，null和undefined都不建议</p><p>规定其他类型但不为其赋值</p><pre><code class="language-typescript">var num:number\nconsole.log(num) // 编译报错：在赋值前使用了变量“num”  打印undefined\n</code></pre><p>规定格式为undefined，将不能再赋值其他数据类型</p><pre><code class="language-typescript">let num:undefined\nconsole.log(num)  // undefined\nnum = 1  // 不能将类型“1”分配给类型“undefined”\n\nlet str:undefined\nnum = str  // 编译正常\nconsole.log(num) // undefined\n\n</code></pre><p>对于不确定变量规定undefined</p><pre><code class="language-typescript">var foo = { x: 123, y: undefined }\nconsole.log(foo)\nfoo = {  // 类型 &quot;{ x: number; }&quot; 中缺少属性 &quot;y&quot;，但类型 &quot;{ x: number; y: undefined; }&quot; 中需要该属性。\n  x: 456\n}\n\n// 可选变量\nlet foo: {x: number, y?: number | undefined | null} = {x: 1}\n</code></pre><h5>void类型</h5><p>规定函数没有返回值</p><pre><code class="language-typescript">function fun(l: number): void {\n  console.log(l) // 10\n}\nconst l: number = 10\nfun(l)\n</code></pre><p>规定函数具有规范类型的返回值</p><pre><code class="language-typescript">function fun(x: number, y: number): number {\n  return x + y\n}\n\nconst x = 2\nconst y = 3\nconst sum = fun(x,y)\nconsole.log(sum) // 5\n</code></pre><h5>never</h5><blockquote><p>程序语言的设计确实应该存在一个底部类型的概念，当你在分析代码流时，这回是一个理所当然存在的类型。typescript就是这样一种分析代码流的语言，因此他需要个可靠的类型来代表哪些永远不会发生的事情。</p><p>never类型就是Typescript中的底部类型，它自然被分配的一些例子如下</p><ul><li>一个从来不会有返回值的函数，例如，如果函数内含有 <code>while(true){}</code> 的话。</li><li>一个总会抛出错误的函数，如 <code>function foo () {throw new Error(&#39;Not Implemented&#39;)}</code> ，foo的返回类型就是never</li></ul></blockquote><pre><code class="language-typescript">var a:never\na = (()=&gt;{\n  return &#39;&#39; // 不能将类型“string”分配给类型“never”。\n})()\n</code></pre><p>可以使用 <code>throw **new** *Error*(&#39;错误&#39;)</code> 捕捉错误</p><pre><code class="language-typescript">var a:never\na = (()=&gt;{\n  // return &#39;&#39; // 不能将类型“string”分配给类型“never”。\n  throw new Error(&#39;错误&#39;)\n})()\n</code></pre><p>index.js:114 Uncaught Error: 错误</p><p>实际操作的案例</p><pre><code class="language-typescript">function foo(x: string | number): boolean {\n  if (typeof x === &#39;string&#39;) {\n    return true\n  } else if (typeof x === &#39;number&#39;) {\n    return false\n  }\n  // 如果不是never类型的，则会报错(函数缺少结束 return 语句，返回类型不包括)\n  // 并非在所有条件下都有返回值（严格的空检查）\n}\n</code></pre><p>正确的操作方法</p><pre><code class="language-typescript">function fail (message: string): never {\n  throw new Error(message)\n}\n\n\nfunction foo(x: string | number): boolean {\n  if (typeof x === &#39;string&#39;) {\n    return true\n  } else if (typeof x === &#39;number&#39;) {\n    return false\n  }\n  // 如果不是never类型的，则会报错(函数缺少结束 return 语句，返回类型不包括)\n  // 并非在所有条件下都有返回值（严格的空检查）\n\n  return fail(&#39;Unexhaustive&#39;)\n}\n\nlet f = foo(&#39;123&#39;)\nconsole.log(f) // true\n\n</code></pre><p>如果将 if语句中的return都去掉，控制台将报错</p><pre><code class="language-typescript">\nfunction fail (message: string): never {\n  throw new Error(message)\n}\n\n\nfunction foo(x: string | number): boolean {\n  if (typeof x === &#39;string&#39;) {\n    // return true\n  } else if (typeof x === &#39;number&#39;) {\n    // return false\n  }\n  // 如果不是never类型的，则会报错(函数缺少结束 return 语句，返回类型不包括)\n  // 并非在所有条件下都有返回值（严格的空检查）\n\n  return fail(&#39;Unexhaustive&#39;)\n}\n\nlet f = foo(&#39;123&#39;)\nconsole.log(f) // Uncaught Error: Unexhaustive\n\n</code></pre><h5>字面量类型</h5><p><code>字面量是javascript本身提供的一个准确变量</code></p><p>可以将一个字符串字面量作为一个类型来使用</p><pre><code class="language-typescript">\n// 创建一个foo变量，字面量值为Hello的变量\nlet foo: &#39;Hello&#39;\n\n/* foo = &#39;bar&#39;  // 不能将类型“&quot;bar&quot;”分配给类型“&quot;Hello&quot;” */\n/* 它们本身并不是很实用，但是可以在一个联合类型中组合创建一个强大且实用的抽象概念*/\n\ntype CarDirection = &#39;Top&#39; | &#39;Bottom&#39; | &#39;Left&#39; | &#39;Right&#39;\n\nfunction move(offset: number, direction: CarDirection){\n  // Do something...\n}\n\nmove(1, &#39;Top&#39;)  // 正确\nmove(1, &#39;center&#39;) // 错误 类型“&quot;center&quot;”的参数不能赋给类型“CarDirection”的参数。\n</code></pre>',70),t={expose:[],setup:o=>(defineExpose({frontmatter:{}}),(o,t)=>(e(),n("div",r,[l])))};export default t;
